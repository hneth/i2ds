% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trans_arrays.R
\name{flatten_array}
\alias{flatten_array}
\title{Flatten a 3D array into a 2D data frame.}
\usage{
flatten_array(x, margin = 2, varsAsFactors = FALSE)
}
\arguments{
\item{x}{A 3-dimensional array.}

\item{margin}{The margin across which \code{\link{c}} is to be applied. 
Default: \code{margin = 2} (i.e., columns).}

\item{varsAsFactors}{Boolean: Should reconstructed variables be factors? 
Default: \code{varsAsFactors = FALSE} (i.e., character variables).}
}
\value{
A data frame.
}
\description{
\code{flatten_array} turns a 3-dimensional array   
into a 2-dimensional data frame (in wide format).
}
\details{
\code{flatten_array} assumes that \code{x} is a 3-dimensional 
\code{\link{array}} with dimension names 
(and calls \code{\link{add_dimnames}} if they are absent). 

The \code{margin} argument specifies an array dimension 
to be passed to \code{apply(x, MARGIN = margin, FUN = c)}. 

\code{flatten_array} returns \code{NA} for non-arrays and  
for arrays with more than 3 dimensions. 

As R objects of class \code{\link{table}} are also arrays 
(contingency tables of frequency counts, in numeric mode) 
\code{flatten_array} works for them as well. 

To flatten numeric arrays or objects of class \code{\link{table}}  
with more then 3 dimensions, use \code{\link{margin.table}} (from \strong{base} R) 
to create a 3-dimensional aggregate first. 

Internally, \code{flatten_array} uses \code{\link{apply}} to apply 
the \code{\link{c}} function to a specified \code{margin} of \code{x}. 
It aims to reconstruct the names of the collapsed variables 
from the initial letters of the dimension names. 

See \code{\link{ftable}} (from the \strong{stats} package) 
for a more general function (in combination with \code{\link{aperm}})  
and \code{\link{margin.table}} (from \strong{base} R) 
and \code{\link{addmargins}} (from \strong{stats}) for aggregating 
over table dimensions.
}
\examples{
a1 <- array(data = LETTERS[1:8], dim = c(2, 2, 2), 
            dimnames = list(c("r1", "r2"), c("c1", "c2"), c("t1", "t2")))
flatten_array(a1)  # using default (margin = 2) 

# Using names of dimnames:
names(dimnames(a1)) <- c("row", "col", "tab")
flatten_array(a1)
flatten_array(a1, margin = 3)  

# Returning name variables as factors:
a1f <- flatten_array(a1, varsAsFactors = TRUE)
is.factor(a1f$r)
is.factor(a1f$t)

a2 <- array(data = 1:60, dim = c(5, 4, 3))  # no dimnames 
flatten_array(a2)  # default names added
flatten_array(a2, margin = 1)   
flatten_array(a2, margin = 3)

a3 <- array(data = 1:2^4, dim = c(2, 2, 2, 2))  # 4-dimensions
flatten_array(a3)
flatten_array(margin.table(a3, margin = 1:3))

# For table:
# UCBAdmissions data (3-dimensions): 
flatten_array(UCBAdmissions) # margin = 2
flatten_array(UCBAdmissions, margin = 1)
flatten_array(UCBAdmissions, margin = 3)

# Titanic data (4-dimensions):
T3d <- margin.table(Titanic, margin = c(2, 3, 4))  # aggregate 3d-array
flatten_array(T3d, margin = 3)  # compare to ftable(T3d)

}
\seealso{
\code{\link{ftable}} for flattening multi-dimensional arrays; 
\code{\link{margin.table}} for aggregating across array dimensions; 
\code{\link{addmargins}} for expanding factor levels on margins; 
\code{\link{aperm}} for permuting array dimensions; 
\code{\link{add_dimnames}} for adding dimension names to arrays.

Other array functions: 
\code{\link{add_dimnames}()},
\code{\link{expand_freq_table}()},
\code{\link{sub_table}()}
}
\concept{array functions}
